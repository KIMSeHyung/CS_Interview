# System Software

* [C언어의 strtok 함수를 멀티쓰레드 환경에서 사용하면 안 되는 이유](#C언어의-strtok-함수를-멀티쓰레드-환경에서-사용하면-안-되는-이유)
* [세마포어, 뮤텍스, 스핀락의 차이점](#세마포어-뮤텍스-스핀락-차이점)
* [스핀락을 사용하는 이유](#스핀락을-사용하는-이유)
* [IPC의 종류와 특징](#IPC-종류와-특징)
* [fork와 vfork의 차이점](#fork와-vfork의-차이점)
* [시나리오 문제](#시나리오-문제)
    * 프로세스A에서 파일A를 open하여 fd 3번을 할당받았다. (아래 Q1와 Q2는 각각 독립적, 오프셋 위치에 대한 이유도 함께 설명)
    * Q1. 그 후 쓰레드를 하나 생성하고, 쓰레드 리더 (쓰레드를 생성한 프로세스) 에서 fd3에 접근하여 파일 오프셋이 100으로 바뀌었다. 그 후 생성된 쓰레드에서 fd 3에 접근하면 오프셋 위치는?
    * Q2. 그 후 자식 프로세스를 하나 생성하고, 부모 프로세스에서 fd 3 에 접근하여 부모 프로세스의 fd 3에 대한 오프셋이 100으로 바뀌었다. 이 후 자식 프로세스에서 fd 3에 접근하면 오프셋의 위치는?
    * Q2-2 자식 프로세스 생성 이후 부모 프로세스와 자식 프로세스가 모두 파일 B에 대해 새로 open하여 fd 4를 할당받았다. 그리고 부모 프로세스가 fd 4에 접근해 오프셋이 100으로 바뀌었다. 그 후 자식 프로세스가 fd4에 접근할 때 오프셋 위치는?

---

## C언어의 strtok 함수를 멀티쓰레드 환경에서 사용하면 안 되는 이유

* strtok 함수는 내부적으로 정적 변수를 사용한다. 여러 쓰레드에서 전역 변수/정적 변수에 동시에 접근하게 되면 Race Condition 문제가 발생한다. 이와 비슷한 문제를 갖는 함수로는, gethostbyname, ctime, rand, srand, 등의 함수가 있다.
* 여러 쓰레드 등에서 병렬 실행을 보장하도록 작성된 함수를 재진입성(Reentrancy)을 만족하는 함수라고 한다. strtok이나 rand 함수의 재진입성 만족 함수는 strtok_r, rand_r 같은 함수가 있다. 그리고 이 재진입성이라는 용어는 SUSv4에서 Thread-safety라는 용어에 흡수되었다.

## 세마포어 뮤텍스 스핀락 차이점

## 스핀락을 사용하는 이유

* 싱글코어 환경에서 동기화 목적으로 인터럽트를 비활성화 해야 하는 경우들이 있다. 그런데 멀티코어 환경으로 넘어가면 인터럽트 비활성화는 코어 별로 작동하므로, 별도의 락 메커니즘을 사용해야 한다. 이 때 락 메커니즘으로 뮤텍스나 세마포어를 사용하게 되면 인터럽트 비활성화가 불가능하다. 따라서 인터럽트를 비활성화하면서 정상적으로 락을 걸기 위하여 스핀락을 사용해야 한다. 이 스핀락의 경우는 다른 락 메커니즘에 비해 자원을 많이 소모하기 때문에 꼭 필요한 상황에서 사용해야 한다.

## IPC 종류와 특징

## fork와 vfork의 차이점

## 시나리오 문제

* A1. 100 - 쓰레드는 쓰레드 리더(쓰레드를 만든 프로세스)의 파일 디스크립터 테이블을 공유하므로 같은 시스템 파일 테이블에 접근하게 된다.
* A2. 100 - fork로 자식 프로세스를 생성했을 때 기존에 열려있던 파일 디스크립터 내용을 물려받게 된다. 부모 프로세스와 자식 프로세스의 파일 포인터가 같은 시스템 파일 테이블을 가리키므로 오프셋도 공유된다.
* A3. 0 - 이 후에 새로 열게되는 파일에 대해서는 서로 다른 시스템 파일 테이블을 가리키게 되므로 오프셋을 공유하지 않는다.
* 개념적으로는 각 프로세스마다 파일 디스크립터 테이블 항목이 있고, 파일 디스크립터 테이블에는 파일 포인터와 파일 디스크립터가 매핑되어 있다. 파일 디스크립터 테이블의 파일 포인터는 시스템의 파일 테이블을 가리킨다. 이 시스템 파일 테이블에는 파일 상태 플래그, 파일 오프셋, v-node 포인터 등이 있다. 그리고 v-node 포인터가 시스템의 v-node 테이블을 가리키고 v-node 테이블로부터 i-node 정보를 찾아갈 수 있다. inode에는 파일의 크기, 위치, 링크 수, 소유자, 시간 등의 메타데이터가 존재한다.
    * 해당 내용은 실제 구현상 조금씩 달라질 수 있다. 예를 들어 리눅스의 경우, vnode가 없이 바로 inode를 갖는다. 시스템 파일 테이블이란 것이 존재하긴 하지만, 프로세스의 파일 디스크립터 테이블에 있는 파일 포인터가 테이블을 가리키지는 않는다.
    * 즉, 리눅스 구현 상으로 프로세스/쓰레드(task_struct)는 파일 디스크립터 테이블(struct files_struct)을 갖고있다. 이 파일 디스크립터 테이블은 커널에서 관리하는 시스템 파일 구조체(struct file)을 가리킨다. 파일 구조체(struct file)은 실제 파일의 메타데이터를 관리하기 위한 inode(struct inode)를 가리킨다. 또한, 파일 구조체(struct file)에 파일 플래그, 파일 소유자, 오프셋 등의 정보가 저장된다.
* 한 프로세스 내에서 dup 시스템 콜을 통해 파일 디스크립터를 복사할 수 있다. 이 경우 같은 시스템 파일 테이블 항목을 가리키는 두 개의 파일 디스크립터가 생긴다.
* 한 프로세스가 fork를 하면 기존 프로세스 파일 디스크립터 테이블 내용을 물려받는다. 즉, 기존에 열려있던 부모 프로세스의 fd 3 파일 포인터와 자식 프로세스의 fd 3 파일 포인터가 같은 시스템 파일 테이블을 가리킨다.
* 이 후 새로 open하는 fd 4번부터는 서로 별개의 시스템 파일 테이블을 가리킨다.