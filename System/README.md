# System Software

* [C언어의 strtok 함수를 멀티쓰레드 환경에서 사용하면 안 되는 이유](#C언어의-strtok-함수를-멀티쓰레드-환경에서-사용하면-안-되는-이유)
* [세마포어, 뮤텍스, 스핀락의 차이점](#세마포어-뮤텍스-스핀락-차이점)
* [스핀락을 사용하는 이유](#스핀락을-사용하는-이유)
* [IPC의 종류와 특징](#IPC-종류와-특징)
* [fork와 vfork의 차이점](#fork와-vfork의-차이점)
* [시나리오 문제](#시나리오-문제)
    * 프로세스A에서 파일A를 open하여 fd 3번을 할당받았다. (아래 문제들은 각각 독립적으로 동작한다고 가정한다. 오프셋 위치에 대한 이유도 함께 설명)
    * Q1. 그 후 쓰레드를 하나 생성하고, 쓰레드 리더 (쓰레드를 생성한 프로세스) 에서 fd3에 접근하여 파일 오프셋이 100으로 바뀌었다. 그 후 생성된 쓰레드에서 fd 3에 접근하면 오프셋 위치는?
    * Q2. 그 후 자식 프로세스를 하나 생성하고, 부모 프로세스에서 fd 3 에 접근하여 부모 프로세스의 fd 3에 대한 오프셋이 100으로 바뀌었다. 이 후 자식 프로세스에서 fd 3에 접근하면 오프셋의 위치는?
    * Q3. Q2와 같이 자식 프로세스를 하나 생성하고, 부모 프로세스와 자식 프로세스가 모두 파일 B에 대해 새로 open하여 fd 4를 할당받았다. 그리고 부모 프로세스가 fd 4에 접근해 오프셋이 100으로 바뀌었다. 그 후 자식 프로세스가 fd4에 접근할 때 오프셋 위치는?

<br>

---

## C언어의 strtok 함수를 멀티쓰레드 환경에서 사용하면 안 되는 이유

* strtok 함수는 내부적으로 정적 변수를 사용한다. 여러 쓰레드에서 전역 변수/정적 변수에 동시에 접근하게 되면 Race Condition 문제가 발생한다. 이와 비슷한 문제를 갖는 함수로는, gethostbyname, ctime, rand, srand, 등의 함수가 있다.
* 여러 쓰레드 등에서 병렬 실행을 보장하도록 작성된 함수를 재진입성(Reentrancy)을 만족하는 함수라고 한다. strtok이나 rand 함수의 재진입성 만족 함수는 strtok_r, rand_r 같은 함수가 있다. 그리고 이 재진입성이라는 용어는 SUSv4에서 Thread-safety라는 용어에 흡수되었다.

## 세마포어 뮤텍스 스핀락 차이점

* 세마포어와 뮤텍스 차이는 추후 추가 예정
* 세마포어나 뮤텍스의 경우 일반적으로 락을 획득하지 못하게 되면 컨텍스트 스위칭을 수행한다. 반면에 스핀락은 락을 획득하지 못해도 계속 자원을 소모하며 busy-waiting을 수행한다.

## 스핀락을 사용하는 이유

* 싱글코어 환경에서 동기화 목적으로 인터럽트를 비활성화 해야 하는 경우들이 있다. 그런데 멀티코어 환경으로 넘어가면 인터럽트 비활성화는 코어 별로 작동하므로, 별도의 락 메커니즘을 사용해야 한다. 이 때 락 메커니즘으로 뮤텍스나 세마포어를 사용하게 되면 인터럽트 비활성화가 불가능하다. 따라서 인터럽트를 비활성화하면서 정상적으로 락을 걸기 위하여 스핀락을 사용해야 한다. 이 스핀락의 경우는 다른 락 메커니즘에 비해 자원을 많이 소모하기 때문에 꼭 필요한 상황에서 사용해야 한다.

## IPC 종류와 특징

* 대표적인 IPC로 파이프, Named 파이프 (FIFO), 공유 메모리, 메시지 큐가 있습니다.
* 일반 파이프는 한쪽 방향으로만 통신이 가능하고, 부모-자식과 같이 서로 연관된 프로세스끼리만 통신이 가능하다.
* Named 파이프는 다른부분은 파이프와 같고 서로 무관한 프로세스 끼리도 통신이 가능하다.
* 메시지 큐는 다수의 프로세스가 메시지를 전달할 수 있게 하는 IPC이다.
* 공유 메모리는 서로 다른 프로세스가 공통된 메모리 공간을 사용할 수 있도록 OS에서 만들어둔 공간을 이용한다.
* 소켓은 서로 다른 호스트들의 통신을 위한 인터페이스로 일종의 IPC이다.
* 실제 로우레벨 시스템 개발 시에 주로 사용되는 IPC 기법은 mmap과 DBUS이다.

## fork와 vfork의 차이점

* ```fork()```는 UNIX 계열에서 새로운 프로세스를 만드는 전통의 함수이다. 새로운 프로세스를 생성할 때, 자식 프로세스가 부모 프로세스를 복제하는 방식으로 생성된다.
* ```fork()```를 사용하는 패턴은 크게 두 가지가 있다. 하나는 멀티 프로세스로 동작하는 어플리케이션을 만드는 경우이고, 하나는 ```fork()``` 후에 다른 프로세스를 실행하는 경우이다. 쉘이나 바탕화면 등에서 프로그램을 새로 시작하는 경우는 전부 후자에 해당하며, 이러한 과정을 fork-exec이라고 부른다.
* ```fork()``` 이후에 바로 ```exec()``` 함수로 새로운 프로세스 이미지 교체 작업이 일어나면, 기존에 부모 프로세스로부터 내용을 복사하는 작업은 무의미한 작업이 된다. 이러한 오버헤드를 피하기 위하여 부모 프로세스의 메모리를 복제하지 않는 ```vfork()``` 함수가 생겼다. ```vfork()``` 함수는 부모 프로세스와 자식 프로세스가 페이지 테이블을 공유하도록 설계된 함수이다.
* 이런 ```vfork()``` 함수로 프로세스를 생성한 후, 자식 프로세스가 ```exec()```을 하기 전에 부모 혹은 자식 프로세스가 다른 작업을 해서 메모리 내용이 변경되면 예측할 수 없는 문제가 발생하였다. 심지어 ```fork()``` 작업 이 후 부모와 자식 프로세스 중 어떤 프로세스가 먼저 실행될지는 정해져있지 않기 때문에 (실제로 이는 OS별/버전별로 다르다) 결과를 예측할 수도 없었다. 이러한 문제들로 인해 표준에서 채택될수조차 없었다.
* 여기에 더해 추후 ```fork()``` 함수에 Copy On Write 기법이 탑재되어, 메모리 복제를 실제 Write 작업이 일어날 때로 미룸으로써 fork-exec 과정에서 무의미한 복제도 일어나지 않게 되었다. 하지만, fork-exec은 성능 외에도 파일 등의 상속 문제가 남아 있었기에 이를 대체하는 ```posix_spawn()``` 함수가 등장하였다. ```posix_spawn()``` 함수는 ```fork()```와 ```exec()``` 과정을 하나의 함수에서 수행하여 위 언급한 문제들을 해결하였다.

## 시나리오 문제

* A1. 100 - 쓰레드는 쓰레드 리더(쓰레드를 만든 프로세스)의 파일 디스크립터 테이블을 공유하므로 같은 시스템 파일 테이블에 접근하게 된다.
* A2. 100 - fork로 자식 프로세스를 생성했을 때 기존에 열려있던 파일 디스크립터 내용을 물려받게 된다. 부모 프로세스와 자식 프로세스의 파일 포인터가 같은 시스템 파일 테이블을 가리키므로 오프셋도 공유된다.
* A3. 0 - 이 후에 새로 열게되는 파일에 대해서는 서로 다른 시스템 파일 테이블을 가리키게 되므로 오프셋을 공유하지 않는다.
* 개념적으로는 각 프로세스마다 파일 디스크립터 테이블 항목이 있고, 파일 디스크립터 테이블에는 파일 포인터와 파일 디스크립터가 매핑되어 있다. 파일 디스크립터 테이블의 파일 포인터는 시스템의 파일 테이블을 가리킨다. 이 시스템 파일 테이블에는 파일 상태 플래그, 파일 오프셋, v-node 포인터 등이 있다. 그리고 v-node 포인터가 시스템의 v-node 테이블을 가리키고 v-node 테이블로부터 i-node 정보를 찾아갈 수 있다. i-node에는 파일의 크기, 위치, 링크 수, 소유자, 시간 등의 메타데이터가 존재한다.
    * 해당 내용은 실제 구현상 조금씩 달라질 수 있다. 예를 들어 리눅스의 경우, v-node가 없이 바로 i-node를 갖는다. 시스템 파일 테이블이란 것이 존재하긴 하지만, 프로세스의 파일 디스크립터 테이블에 있는 파일 포인터가 테이블을 가리키지는 않는다.
    * 즉, 리눅스 구현 상으로 프로세스/쓰레드(```struct task_struct```)는 파일 디스크립터 테이블(```struct files_struct```)을 갖고있다. 이 파일 디스크립터 테이블은 커널에서 관리하는 시스템 파일 구조체(```struct file```)을 가리킨다. 파일 구조체(```struct file```)은 실제 파일의 메타데이터를 관리하기 위한 i-node(```struct inode```)를 가리킨다. 또한, 파일 구조체(```struct file```)에 파일 플래그, 파일 소유자, 오프셋 등의 정보가 저장된다.
    * FreeBSD의 경우 위 개념과 실제 구현이 거의 일치한다.
* 한 프로세스 내에서 dup 시스템 콜을 통해 파일 디스크립터를 복사할 수 있다. 이 경우 같은 시스템 파일 테이블 항목을 가리키는 두 개의 파일 디스크립터가 생긴다.
* 한 프로세스가 fork를 하면 기존 프로세스 파일 디스크립터 테이블 내용을 물려받는다. 즉, 기존에 열려있던 부모 프로세스의 fd 3 파일 포인터와 자식 프로세스의 fd 3 파일 포인터가 같은 시스템 파일 테이블을 가리킨다.
* 이 후 새로 open하는 fd 4번부터는 서로 별개의 시스템 파일 테이블을 가리킨다.