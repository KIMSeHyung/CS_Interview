# Network

* [OSI 7 Layer](#OSI-7-Layer)
* [TCP UDP 차이](#TCP-UDP-차이)
* [TCP 3 way handshake](#TCP-3-way-handshake)
* [TCP 4 way handshake](#TCK-4-way-handshake)
* 흐름제어와 혼잡제어(#흐름제어와-혼잡제어)
* [BGP 프로토콜](#BGP-프로토콜)

<br>

---

## OSI 7 Layer

* OSI 참조 모델은 네트워킹 시스템 구조를 위한 통합 표준을 위해 만들어졌다.
    * OSI 참조 모델은 원래 개념/교육용이 아니라, 인터네트워크에서 사용할 프로토콜 슈트 개발을 위해 만들어졌다. 하지만 인터넷과 TCP/IP가 성장하여 OSI 프로토콜은 사장되었다.
    * OSI 모델이 네트워크를 이해하기 위한 구조를 정의하기는 하지만 모든 네트워킹 구성 요소, 프로토콜, 기술이 OSI 모델의 계층 구조에 정확히 들어 맞는 것은 아니다.
* OSI 참조 모델 계층
    * 애플리케이션
        * 역할 : 사용자 애플리케이션 서비스 제공
        * 데이터 유닛 : 메세지, 사용자 데이터
        * 대표 프로토콜 : HTTP, FTP, SMTP, DHCP, NFS, Telnet, SNMP, POP3
    * 프리젠테이션
        * 역할 : 번역(Translation), 압축, 암호화
        * 데이터 유닛 : 인코딩 데이터
        * 대표 프로토콜 : MIME, SSL(세션 계층으로 보기도 함)
    * 세션
        * 역할 : 세션 생성/유지/종료, 인터페이스
        * 데이터 유닛 : 세션
        * 대표 프로토콜 : NetBIOS, RPC, 소켓
    * 전송
        * 역할 : 프로세스 수준 주소 지정, 다중화와 역다중화, 단편화/패키징/재조합, 연결 수립/유지/종료, 승인 및 재전송, 흐름 제어
        * 데이터 유닛 : 세그먼트
        * 대표 프로토콜 : TCP, UDP
    * 네트워크
        * 역할 : 논리적 주소 지정, 라우팅, 데이터그램 캡슐화, 단편화와 재조합, 에러 처리 및 진단
        * 데이터 유닛 : 패킷, 데이터그램
        * 대표 프로토콜 : IP, ICMP, ARP, RIP, OSPF, BGP
    * 데이터링크
        * 역할 : 논리적 연결 제어(LLC, Logical Link Control), 매체 접근 제어(MAC, Media Access Control), 데이터 프레이밍(Data Framing), 주소 지정, 에러 탐지 및 처리, 물리 계층 표준 명시
        * 데이터 유닛 : 프레임
        * 대표 프로토콜 : 이더넷, HDLC, PPP, 802.11
    * 물리
        * 역할 : 하드웨어 명세 정의, 인코딩, 물리적 데이터 송수신, 토폴로지와 물리 네트워크 설계
        * 데이터 유닛 : 비트

## TCP UDP 차이

* TCP
    * 애플리케이션이 데이터를 안정적으로 송수신할 수 있도록 하는 프로토콜
    * 연결형 프로토콜로 전송 전에 먼저 연결을 맺어야 한다.
    * 스트림 기반으로 데이터의 경계(boundary)가 없다.
    * 메시지 전송을 신뢰할 수 있으며 모든 데이터에 대한 승인이 있다.
    * 모든 데이터 전송을 관리하며, 손실된 데이터는 자동으로 재전송한다.
    * 슬라이딩 윈도우를 이용하여 흐름 제어를 한다. 또한 윈도우 크기를 조정하고 혼잡 회피 알고리즘을 사용한다.
    * UDP에 비하면 느리고 부하가 생긴다. (절대적인 수치가 낮은 것은 아니다.)
    * 신뢰할 수 있는 방법으로 데이터를 송수신 해야 하는 애플리케이션에 적합하다.
    * FTP, Telnet, SMTP, DNS(메시지가 512B를 초과하거나 Zone File 송수신 경우), HTTP(1.0 ~ 2.0), POP, BGP
* UDP
    * 단순하고 빠르게 애플리케이션이 네트워크 계층에 접근할 수 있도록 하는 인터페이스를 제공하는 프로토콜
    * 비연결형 프로토콜로 연결 수립 없이 데이터를 송수신한다.
    * 메시지 기반으로 데이터의 경계(boundary)가 있다.
    * 메시지 전송에 대한 신뢰성이 없다.
    * 자체적으로 재전송을 수행하지 않는다.
    * 데이터 흐름 관리 기능이 없다.
    * 부하와 전송속도가 매우 빠르다.
    * 데이터의 완전성보다 전달 속도가 중요한 애플리케이션에 적합하다.
    * 멀티미디어 애플리케이션, DNS(일반적인 쿼리 경우), DHCP, RIP, SNMP, HTTP(3.0, QUIC)

## TCP 3 way handshake

* TCP 통신을 하기 위하여 클라이언트와 서버 간에 SYN, SYN/ACK, ACK 세 번의 트랜잭션을 주고 받아서 연결을 맺는 과정
1. 클라이언트 -> 서버 : SYN
    * 클라이언트가 서버에게 임의의 SEQ 넘버로 SYN 플래그가 설정된 패킷을 송신한다. (일반적으로 connect() 함수를 호출한다.)
    * PORT 상태 : 클라이언트(SYN_SENT), 서버(LISTEN)
2. 서버 -> 클라이언트 : SYN + ACK
    * 서버는 SEQ 넘버를 랜덤, ACK 넘버를 수신한 SEQ + 1로 지정하고, SYN과 ACK 플래그를 설정한 패킷을 송신한다.
    * PORT 상태 : 서버(SYN_RCVD), 클라이언트(SYN_SENT)
3. 클라이언트 -> 서버 : ACK
    * 클라이언트는 SEQ 넘버를 수신한 ACK, ACK 넘버를 수신한 SEQ + 1로 지정하고, ACK 플래그를 설정한 패킷을 송신한다.
    * PORT 상태 : 클라이언트(ESTABLISHED), 서버(ESTABLISHED)

## TCP 4 way handshake

* TCP 연결을 안정적으로 해제하기 위하여 클라이언트와 서버 간에 FIN, ACK, FIN, ACK 네 번의 트랜잭션을 주고 받는 과정
* 보통 연결 종료는 클라이언트에서 먼저 시도한다. 하지만 서버 측에서도 timeout 등의 이유로 먼저 연결 종료를 시도할 수도 있다. 아래 과정은 클라이언트가 active close, 서버가 passive close 하는 상황을 가정한다.
1. 클라이언트 -> 서버 : FIN
    * 클라이언트가 서버에게 FIN 플래그가 설정된 패킷을 송신한다. (일반적으로 close() 함수를 호출한다.)
    * PORT 상태 : 클라이언트(FIN_WAIT1), 서버(ESTABLISHED)
2. 서버 -> 클라이언트 : ACK
    * 서버가 클라이언트에게 ACK 플래그가 설정된 패킷을 송신한다.
    * PORT 상태 : 서버(CLOSE_WAIT), 클라이언트(FIN_WAIT2)
3. 서버 -> 클라이언트 : FIN
    * 서버가 클라이언트에게 FIN 플래그가 설정된 패킷을 송신한다. (일반적으로 close() 함수를 호출한다.)
    * PORT 상태 : 서버(LAST_ACK), 클라이언트(FIN_WAIT2)
4. 클라이언트 -> 서버 : ACK
    * 클라이언트가 서버에게 ACK 플래그가 설정된 패킷을 송신한다.
    * PORT 상태 : 클라이언트(TIME_WAIT), 서버(CLOSED)
* FIN_WAIT1은 자신이 보낸 FIN 패킷에 대해 ACK을 기다리는 상태이고, FIN_WAIT2는 상대방의 FIN 패킷을 기다리는 상태이다. FIN과 ACK을 함께 보내지 않는 이유는, ACK은 TCP 시스템상 즉각 응답하는 패킷이고 FIN은 프로세스가 passive close 과정을 거쳐서 전송하는 패킷이기 때문이다.
* active close 하는 측이 마지막 ACK 패킷을 송신하고 나면 TIME_WAIT 상태가 된다. TIME_WAIT 상태에서 MSL(Maximum Segment Lifetime)의 2배의 시간만큼 기다리며 해당 포트를 점유하는데, 이 시간동안 해당 포트 주소를 사용할 수 없다.
    * TIME_WAIT 상태는 마지막으로 송신한 ACK 패킷이 유실되는 경우를 대비한 상태이다. passive close 측이 LAST_ACK 상태에서 (ACK 패킷 유실 등의 이유로) 일정 시간동안 ACK 패킷을 받지 못하면 FIN 패킷을 재전송한다. 만약 TIME_WAIT 상태 없이 active close 측이 바로 소켓을 close 했다면 위 상황에서 재전송한 FIN 패킷을 수신할 수 없게 된다. 따라서, TIME_WAIT 상태로 일정 시간동안 FIN 패킷의 재전송을 기다린 후 CLOSE 하게 된다.
    * 하지만 connect/close가 자주 발생하는 환경에서는 TIME_WAIT 상태 때문에 포트 번호 고갈이 일어날 수 있다. 이런 상황을 해소하기 위하여 소켓에 SO_REUSEADDR이나 SO_LINGER 옵션을 사용하여 포트 주소를 강제로 재사용하거나 접속을 강제로 해제할 수도 있지만, 위와 같은 문제의 소지가 생길 수 있다. 따라서, 네트워크 프로그램 개발 시 Keep-Alive 세션 등을 통해 과도한 접속과 해제를 하지 않도록 설계해야 한다.
* 작성한 프로그램(active close 측)에서 FIN_WAIT2 상태가 계속 보인다면 상대편 프로세스(passive close 측)에서 FIN 패킷을 주고 있지 않는 것이므로 상대편 프로세스에 close() 루틴이 제대로 동작하지 않는 것이다. 반대로 작성한 프로그램(passive close 측)에서 CLOSE_WAIT이 계속 발생한다면 FIN 패킷을 수신하여 ACK 응답을 한 후, FIN 패킷을 송신하지 않고 있다는 것이다. 즉, 작성한 프로그램에서 close() 루틴이 제대로 동작하지 않는 것이다.

## 흐름제어와 혼잡제어

* 흐름제어는 송신측의 데이터 전송 속도보다 수신측의 데이터 처리 속도가 느린 경우 생기는 패킷 유실을 제어하는 것이다. 일반적으로 슬라이딩 윈도우를 통해 흐름 제어를 구현한다.
    * 수신 측에서 송신 측에게 윈도우 크기(수신 측의 버퍼 크기)를 알려준다.
    * 송신 측에서 수신 측의 윈도우 크기를 알고 있으므로 해당 크기 만큼은 ACK 응답을 받지 않고도 데이터를 송신하여 통신 속도를 높인다. 송신 측에서는 데이터를 보낼 때마다 알고 있는 윈도우 크기를 송신한 데이터 크기 만큼 감소시킨다. 즉, 윈도우 크기가 0보다 크다면 계속 데이터를 송신할 수 있다.
* 혼잡제어는 네트워크 내에 패킷이 과도하게 증가하여 패킷이 손실하는 현상을 방지 및 제어하는 것이다.
    * TCP는 각 연결마다 congestion window를 관리한다. congestion window size는 ACK 패킷이 수신되지 않은 패킷의 최대 개수이다. TCP는 연결이 시작되었을 때와 timeout이 발생했을 때(재전송이 발생할 때), slow start라는 상태에 진입한다. 해당 상태에서 congestion window size는 작은 값을 갖고, 점차 size를 늘려준다. 일반적으로 처음 congestion window size는 MSS의 두 배이며(과거 1배), 각 패킷에 대해 ACK 패킷을 받을 때마다 size는 MSS의 크기 만큼 늘어난다. 따라서, 매 왕복 마다 size는 두 배가 된다.
    * congestion window size가 ssthresh라고 불리는 한계점을 초과하면 혼잡 방지 상태에 진입한다. 대표적인 혼잡 방지 알고리즘은 다음과 같다.
        * TCP Tahoe : ACK 중복 수신이 3회 발생하거나 timeout이 발생하면 ssthresh 값을 현재 window size의 반으로 설정하고, window size는 MSS의 크기와 같게 설정한 후, 다시 slow start 상태로 진입한다.
        * TCP Reno : ACK 중복 수신이 3회 발생하면 window size를 반으로 줄이고 이 후 window size를 선형 증가시킨다. timeout 시에는 Tahoe와 같은 방식으로 동작한다.

## BGP 프로토콜

* 현대 TCP/IP에서 사용하는 외부 라우팅 프로토콜은 BGP이다. BGP는 EGP를 대체하기 위해 개발되고 개정되어 현재는 BGP-4 버전을 사용한다. BGP 프로토콜은 AS(Autonomous System, 자치 시스템)간에 네트워크 접근 가능 정보를 교환하고 그 정보를 통해 네트워크 경로를 결정한다.
* 각 AS는 BGP 소프트웨어를 실행하는 하나 이상의 라우터가 있어야 하며, BGP 라우터는 서로 연결되어 있어야 한다.
* BGP 라우터는 네트워크에 관한 정보와 경로를 라우팅 정보 기반(RIB)에 저장하고 BGP 라우터끼리 라우팅 정보를 교환하여 인터네트워크에 전파한다.
