# Network

* [OSI 7 Layer](#OSI-7-Layer)
* [TCP UDP 차이](#TCP-UDP-차이)
* [TCP 3 way handshake](#TCP-3-way-handshake)
* [TCP 4 way handshake](#TCK-4-way-handshake)
* [흐름제어와 혼잡제어](#흐름제어와-혼잡제어)
* [BGP 프로토콜](#BGP-프로토콜)
* [DNS 프로토콜](#DNS-프로토콜)
* [DHCP 프로토콜](#DHCP-프로토콜)
* [네트워크 장비](#네트워크-장비)

<br>

---

## OSI 7 Layer

* OSI 참조 모델은 네트워킹 시스템 구조를 위한 통합 표준을 위해 만들어졌다.
    * OSI 참조 모델은 원래 개념/교육용이 아니라, 인터네트워크에서 사용할 프로토콜 슈트 개발을 위해 만들어졌다. 하지만 인터넷과 TCP/IP가 성장하여 OSI 프로토콜은 사장되었다.
    * OSI 모델이 네트워크를 이해하기 위한 구조를 정의하기는 하지만 모든 네트워킹 구성 요소, 프로토콜, 기술이 OSI 모델의 계층 구조에 정확히 들어 맞는 것은 아니다.
* OSI 참조 모델 계층
    * 애플리케이션
        * 역할 : 사용자 애플리케이션 서비스 제공
        * 데이터 유닛 : 메세지, 사용자 데이터
        * 대표 프로토콜 : HTTP, FTP, SMTP, DHCP, NFS, Telnet, SNMP, POP3
    * 프리젠테이션
        * 역할 : 번역(Translation), 압축, 암호화
        * 데이터 유닛 : 인코딩 데이터
        * 대표 프로토콜 : MIME, SSL(세션 계층으로 보기도 함)
    * 세션
        * 역할 : 세션 생성/유지/종료, 인터페이스
        * 데이터 유닛 : 세션
        * 대표 프로토콜 : NetBIOS, RPC, 소켓
    * 전송
        * 역할 : 프로세스 수준 주소 지정, 다중화와 역다중화, 단편화/패키징/재조합, 연결 수립/유지/종료, 승인 및 재전송, 흐름 제어
        * 데이터 유닛 : 세그먼트
        * 대표 프로토콜 : TCP, UDP
    * 네트워크
        * 역할 : 논리적 주소 지정, 라우팅, 데이터그램 캡슐화, 단편화와 재조합, 에러 처리 및 진단
        * 데이터 유닛 : 패킷, 데이터그램
        * 대표 프로토콜 : IP, ICMP, ARP, RIP, OSPF, BGP
    * 데이터링크
        * 역할 : 논리적 연결 제어(LLC, Logical Link Control), 매체 접근 제어(MAC, Media Access Control), 데이터 프레이밍(Data Framing), 주소 지정, 에러 탐지 및 처리, 물리 계층 표준 명시
        * 데이터 유닛 : 프레임
        * 대표 프로토콜 : 이더넷, HDLC, PPP, 802.11
    * 물리
        * 역할 : 하드웨어 명세 정의, 인코딩, 물리적 데이터 송수신, 토폴로지와 물리 네트워크 설계
        * 데이터 유닛 : 비트

## TCP UDP 차이

* TCP
    * 애플리케이션이 데이터를 안정적으로 송수신할 수 있도록 하는 프로토콜
    * 연결형 프로토콜로 전송 전에 먼저 연결을 맺어야 한다.
    * 스트림 기반으로 데이터의 경계(boundary)가 없다.
    * 메시지 전송을 신뢰할 수 있으며 모든 데이터에 대한 승인이 있다.
    * 모든 데이터 전송을 관리하며, 손실된 데이터는 자동으로 재전송한다.
    * 슬라이딩 윈도우를 이용하여 흐름 제어를 한다. 또한 윈도우 크기를 조정하고 혼잡 회피 알고리즘을 사용한다.
    * UDP에 비하면 느리고 부하가 생긴다. (절대적인 수치가 낮은 것은 아니다.)
    * 신뢰할 수 있는 방법으로 데이터를 송수신 해야 하는 애플리케이션에 적합하다.
    * FTP, Telnet, SMTP, DNS(메시지가 512B를 초과하거나 Zone File 송수신 경우), HTTP(1.0 ~ 2.0), POP, BGP
* UDP
    * 단순하고 빠르게 애플리케이션이 네트워크 계층에 접근할 수 있도록 하는 인터페이스를 제공하는 프로토콜
    * 비연결형 프로토콜로 연결 수립 없이 데이터를 송수신한다.
    * 메시지 기반으로 데이터의 경계(boundary)가 있다.
    * 메시지 전송에 대한 신뢰성이 없다.
    * 자체적으로 재전송을 수행하지 않는다.
    * 데이터 흐름 관리 기능이 없다.
    * 부하와 전송속도가 매우 빠르다.
    * 데이터의 완전성보다 전달 속도가 중요한 애플리케이션에 적합하다.
    * 멀티미디어 애플리케이션, DNS(일반적인 쿼리 경우), DHCP, RIP, SNMP, HTTP(3.0, QUIC)

## TCP 3 way handshake

* TCP 통신을 하기 위하여 클라이언트와 서버 간에 SYN, SYN/ACK, ACK 세 번의 트랜잭션을 주고 받아서 연결을 맺는 과정
1. 클라이언트 -> 서버 : SYN
    * 클라이언트가 서버에게 임의의 SEQ 넘버로 SYN 플래그가 설정된 패킷을 송신한다. (일반적으로 connect() 함수를 호출한다.)
    * PORT 상태 : 클라이언트(SYN_SENT), 서버(LISTEN)
2. 서버 -> 클라이언트 : SYN + ACK
    * 서버는 SEQ 넘버를 랜덤, ACK 넘버를 수신한 SEQ + 1로 지정하고, SYN과 ACK 플래그를 설정한 패킷을 송신한다.
    * PORT 상태 : 서버(SYN_RCVD), 클라이언트(SYN_SENT)
3. 클라이언트 -> 서버 : ACK
    * 클라이언트는 SEQ 넘버를 수신한 ACK, ACK 넘버를 수신한 SEQ + 1로 지정하고, ACK 플래그를 설정한 패킷을 송신한다.
    * PORT 상태 : 클라이언트(ESTABLISHED), 서버(ESTABLISHED)

## TCP 4 way handshake

* TCP 연결을 안정적으로 해제하기 위하여 클라이언트와 서버 간에 FIN, ACK, FIN, ACK 네 번의 트랜잭션을 주고 받는 과정
* 보통 연결 종료는 클라이언트에서 먼저 시도한다. 하지만 서버 측에서도 timeout 등의 이유로 먼저 연결 종료를 시도할 수도 있다. 아래 과정은 클라이언트가 active close, 서버가 passive close 하는 상황을 가정한다.
1. 클라이언트 -> 서버 : FIN
    * 클라이언트가 서버에게 FIN 플래그가 설정된 패킷을 송신한다. (일반적으로 close() 함수를 호출한다.)
    * PORT 상태 : 클라이언트(FIN_WAIT1), 서버(ESTABLISHED)
2. 서버 -> 클라이언트 : ACK
    * 서버가 클라이언트에게 ACK 플래그가 설정된 패킷을 송신한다.
    * PORT 상태 : 서버(CLOSE_WAIT), 클라이언트(FIN_WAIT2)
3. 서버 -> 클라이언트 : FIN
    * 서버가 클라이언트에게 FIN 플래그가 설정된 패킷을 송신한다. (일반적으로 close() 함수를 호출한다.)
    * PORT 상태 : 서버(LAST_ACK), 클라이언트(FIN_WAIT2)
4. 클라이언트 -> 서버 : ACK
    * 클라이언트가 서버에게 ACK 플래그가 설정된 패킷을 송신한다.
    * PORT 상태 : 클라이언트(TIME_WAIT), 서버(CLOSED)
* FIN_WAIT1은 자신이 보낸 FIN 패킷에 대해 ACK을 기다리는 상태이고, FIN_WAIT2는 상대방의 FIN 패킷을 기다리는 상태이다. FIN과 ACK을 함께 보내지 않는 이유는, ACK은 TCP 시스템상 즉각 응답하는 패킷이고 FIN은 프로세스가 passive close 과정을 거쳐서 전송하는 패킷이기 때문이다.
* active close 하는 측이 마지막 ACK 패킷을 송신하고 나면 TIME_WAIT 상태가 된다. TIME_WAIT 상태에서 MSL(Maximum Segment Lifetime)의 2배의 시간만큼 기다리며 해당 포트를 점유하는데, 이 시간동안 해당 포트 주소를 사용할 수 없다.
    * TIME_WAIT 상태는 마지막으로 송신한 ACK 패킷이 유실되는 경우를 대비한 상태이다. passive close 측이 LAST_ACK 상태에서 (ACK 패킷 유실 등의 이유로) 일정 시간동안 ACK 패킷을 받지 못하면 FIN 패킷을 재전송한다. 만약 TIME_WAIT 상태 없이 active close 측이 바로 소켓을 close 했다면 위 상황에서 재전송한 FIN 패킷을 수신할 수 없게 된다. 따라서, TIME_WAIT 상태로 일정 시간동안 FIN 패킷의 재전송을 기다린 후 CLOSE 하게 된다.
    * 하지만 connect/close가 자주 발생하는 환경에서는 TIME_WAIT 상태 때문에 포트 번호 고갈이 일어날 수 있다. 이런 상황을 해소하기 위하여 소켓에 SO_REUSEADDR이나 SO_LINGER 옵션을 사용하여 포트 주소를 강제로 재사용하거나 접속을 강제로 해제할 수도 있지만, 위와 같은 문제의 소지가 생길 수 있다. 따라서, 네트워크 프로그램 개발 시 Keep-Alive 세션 등을 통해 과도한 접속과 해제를 하지 않도록 설계해야 한다.
* 작성한 프로그램(active close 측)에서 FIN_WAIT2 상태가 계속 보인다면 상대편 프로세스(passive close 측)에서 FIN 패킷을 주고 있지 않는 것이므로 상대편 프로세스에 close() 루틴이 제대로 동작하지 않는 것이다. 반대로 작성한 프로그램(passive close 측)에서 CLOSE_WAIT이 계속 발생한다면 FIN 패킷을 수신하여 ACK 응답을 한 후, FIN 패킷을 송신하지 않고 있다는 것이다. 즉, 작성한 프로그램에서 close() 루틴이 제대로 동작하지 않는 것이다.

## 흐름제어와 혼잡제어

* 흐름제어는 송신측의 데이터 전송 속도보다 수신측의 데이터 처리 속도가 느린 경우 생기는 패킷 유실을 제어하는 것이다. 일반적으로 슬라이딩 윈도우를 통해 흐름 제어를 구현한다.
    * 수신 측에서 송신 측에게 윈도우 크기(수신 측의 버퍼 크기)를 알려준다.
    * 송신 측에서 수신 측의 윈도우 크기를 알고 있으므로 해당 크기 만큼은 ACK 응답을 받지 않고도 데이터를 송신하여 통신 속도를 높인다. 송신 측에서는 데이터를 보낼 때마다 알고 있는 윈도우 크기를 송신한 데이터 크기 만큼 감소시킨다. 즉, 윈도우 크기가 0보다 크다면 계속 데이터를 송신할 수 있다.
* 혼잡제어는 네트워크 내에 패킷이 과도하게 증가하여 패킷이 손실하는 현상을 방지 및 제어하는 것이다.
    * TCP는 각 연결마다 congestion window를 관리한다. congestion window size는 ACK 패킷이 수신되지 않은 패킷의 최대 개수이다. TCP는 연결이 시작되었을 때와 timeout이 발생했을 때(재전송이 발생할 때), slow start라는 상태에 진입한다. 해당 상태에서 congestion window size는 작은 값을 갖고, 점차 size를 늘려준다. 일반적으로 처음 congestion window size는 MSS의 두 배이며(과거 1배), 각 패킷에 대해 ACK 패킷을 받을 때마다 size는 MSS의 크기 만큼 늘어난다. 따라서, 매 왕복 마다 size는 두 배가 된다.
    * congestion window size가 ssthresh라고 불리는 한계점을 초과하면 혼잡 방지 상태에 진입한다. 대표적인 혼잡 방지 알고리즘은 다음과 같다.
        * TCP Tahoe : ACK 중복 수신이 3회 발생하거나 timeout이 발생하면 ssthresh 값을 현재 window size의 반으로 설정하고, window size는 MSS의 크기와 같게 설정한 후, 다시 slow start 상태로 진입한다.
        * TCP Reno : ACK 중복 수신이 3회 발생하면 window size를 반으로 줄이고 이 후 window size를 선형 증가시킨다. timeout 시에는 Tahoe와 같은 방식으로 동작한다.

## BGP 프로토콜

* 현대 TCP/IP에서 사용하는 외부 라우팅 프로토콜은 BGP이다. BGP는 EGP를 대체하기 위해 개발되고 개정되어 현재는 BGP-4 버전을 사용한다. BGP 프로토콜은 AS(Autonomous System, 자치 시스템)간에 네트워크 접근 가능 정보를 교환하고 그 정보를 통해 네트워크 경로를 결정한다.
* 각 AS는 BGP 소프트웨어를 실행하는 하나 이상의 라우터가 있어야 하며, BGP 라우터는 서로 연결되어 있어야 한다.
* BGP 라우터는 네트워크에 관한 정보와 경로를 라우팅 정보 기반(RIB)에 저장하고 BGP 라우터끼리 라우팅 정보를 교환하여 인터네트워크에 전파한다.

## DNS 프로토콜

* DNS(Domain Name Service)는 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행한다.
* DNS에서 도메인이란 어떤 공통적인 특징에 근거하여 수집된 단일 객체 또는 객체 집합이다. 일반적으로 DNS에서 의미하는 공통적인 특징이란 동일한 기관에 의해 관리되는 것을 의미한다.
* DNS의 네임 계층 구조와 DNS 계층 기관 구조는 매우 밀접하게 연관되어 있으며, 정확히 일치하지는 않지만 양측 다 계층적 트리 구조로 구성되어 있다.
    * 도메인 트리 구조는 루트, 최상위 도메인(TLDs), 2단계 도메인, 하위 도메인(subdomain)으로 구성된다.
* DNS 공개 네임 정보는 권한 계층에 필적하는 계층으로 구조화된 DNS 네임 서버상의 분산 데이터베이스에 저장된다. 각 구역은 자신의 정보를 관장하는 하나 이상의 DNS 네임 서버를 가지는데 이러한 서버를 권한 네임 서버라고 한다.
* DNS 네임 서버는 DNS 정보를 자원 레코드(RR) 형태로 저장한다. RR은 DNS 트리상의 노드에 대해 특정한 유형의 정보를 포함한다. RR에는 이진 필드 포맷 표현법과 문자 마스터 파일 표현법이 있다. 이진 필드 포맷은 DNS 네임 서버와 변환기(Resolver) 사이의 통신에 사용하며 문자 마스터 파일은 DNS 구역을 운영하기 위하여 관리자가 수정한다.
* DNS 네임 서버는 구역에 대한 1차 책임을 갖고 있는 마스터 서버, 백업/유지/부하 관리를 위한 2차 슬레이브 서버, 자체적인 DNS RR은 유지하지 않고 다른 구역에서 최근 사용한 정보를 저장하는 캐싱 전용 서버가 있다.
* DNS의 기능
    * DNS 네임 공간 : DNS는 모든 네임에 적합한 다계층 구조의 계층적 네임 공간을 사용한다. 네임 공간은 하나의 루트에서 시작해 도메인이라고 부르는 컨테이너로 편성된다.
        * 계층적 네임 구조
        * DNS 네임 구조 및 명명 방법
        * 도메인 네임 명세
    * DNS 네임 등록 : DNS 네임 등록은 DNS의 분산 데이터베이스에 개개의 네임을 입력하는 데 사용한다. DNS는 권한 기관을 계층적으로 배열하는데 이는 계층 네임 공간과 상호보완적이다. 중앙 기관은 네임 공간의 전체적인 모양과 구조를 결정하며 최상위 단계에서의 네임 등록을 처리한다. 그 다음 네임 공간의 각 부분을 관리하는 여러 기관으로 권한을 위임한다. 그리고 일반적인 정책을 통해 네임 등록 과정을 제어하고 충돌과 같은 문제를 해결한다.
        * 계층적 권한 구조
        * 인터넷 최상위 도메인 계층
        * 2단계 도메인 등록 절차
        * DNS 구역/Zone과 계층 관리
    * 네임 서버와 네임 변환 : DNS는 분산 클라이언트/서버 네임 변환 방식을 사용한다. 네임 변환 과정은 *서버 역할의 네임 서버와 클라이언트 역할의 변환기(resolver)*로 구현한다. DNS 네임 서버는 하드웨어 서버에서 동작하는 특수 프로그램으로, 이 서버는 DNS 네임 공간 각 부분에 대한 관리 제어 권한을 가지는 조직에서 관리한다. 그리고 이 조직은 네임, 주소, 네임 공간의 특징에 대한 설명을 담고 있는 자원 레코드도 유지한다. **네임 서버의 주된 작업은 네임 변환 요청을 받은 후 데이터베이스에서 자료를 가져와 응답하거나 해당 정보를 알려줄 다른 네임 서버의 네임을 알려주는 것이다.** 네임 변환기(Resolver)는 네임 변환 과정에서 클라이언트로 동작한다. 사용자가 네트워크 애플리케이션에 네임을 입력하면 네임은 변환기에게 전달된다. 변환기는 해당 네임에 대한 변환 요청을 네임 서버로 보낸다. 변환기는 캐싱을 사용하거나 다른 기능을 구현할 수도 있다.
        * DNS 자원 기록 및 마스터 파일
        * 네임 서버의 유형, 역할, 기능
        * 네임 변환기와 변환 절차
        * DNS 메시지의 형식과 표기법
* DNS 네임 변환에는 반복전 변환과 재귀적 변환이라는 두 가지 방법이 있다. 반복적 변환에서는 클라이언트가 적절한 정보를 가지고 있지 않은 네임 서버에게 요청을 보내면 서버는 다른 네임 서버 주소를 알려준다. 재귀적 변환에서는 클라이언트가 요청한 정보가 없는 서버에게 요청을 보내면 서버가 필요한 레코드를 찾아내기 위해 다른 서버에게 요청을 보낸다. 이 서버는 다른 서버로 요청을 보내는데 있어 클라이언트의 역할을 맡는다.
* DNS 네임 서버가 수행하는 캐싱과 더불어 많은 DNS 변환기 또한 최근의 변환 요청 결과를 캐싱한다. 동일한 네임에 대한 다수의 요청이 발생할 때 네임 변환 전에 미리 캐시를 검사한다. 그 외에도 네임 변환 요청 전에 호스트 테이블 방식을 통해 로컬 변환을 시도한다.
* DNS 네임 변환 예시
    * 해당 내용은 TCP/IP 완벽 가이드 내용을 참고한다.
    * 다음 내용은 XYZ 회사의 직원이 자신의 웹 브라우저에 대학 네트워크 부서 웹 서버 주소인 www.net.compsci.googleplex.edu를 입력했을 때 이 네임에 대한 변환 절차를 설명한다.
        * XYZ 회사가 xyzindustries.com 구역을 위한 네임 서버(ns1.xyzindustries.com/ns2.xyzindustries.com)을 운영한다고 가정한다. DNS 서버가 회사 내 머신으로부터의 재귀적 요청을 받아들이며, 서버와 변환기 모두 캐싱을 수행한다. 예제에서는 현재 캐시가 비어있다고 가정한다.
        * Googleplex 대학은 googleplex.edu 도메인을 위한 자체 DNS 서버(compsci.googleplex.edu/admin.googleplex.edu)를 운영한다고 가정한다. 여기서 compsci.googleplex.edu는 전용 서버를 가지고 개별적인 구역에 있지만 다른 하위 도메인은 googleplex.edu 구역 내에 있다고 가정한다.
    * ![DNS_Resolutino](https://github.com/pr0gr4m/CS_Interview/blob/main/img/DNS_Resolution.png?raw=true)
    1. 네임에 대한 요청을 웹 브라우저가 인식하고 www.net.compsci.googleplex.edu라는 네임을 변환기에게 넘겨주며 로컬 변환기를 호출한다.
    2. 변환기는 자신의 캐시에 네임 주소가 저장되어 있는지 확인한다. 캐시되어 있다면 웹 브라우저에게 바로 주소를 반환하지만 그렇지 않다고 가정한다. 변환기는 로컬 호스트 테이블 파일에 해당 항목이 있는지도 검사하는데, 예제에는 테이블에 엔트리 또한 없다고 가정한다.
    3. 변환기가 재귀적 질의를 생성한 후 이를 변환기가 이미 알고 있는 네임 서버의 IP 주소를 통해 ns1.xyzindustries.com에 보낸다.
    4. 로컬 DNS 서버는 요청을 받고 자신의 캐시를 확인한다. 만약 캐시에 정보가 있다면 non-authoritative라고 표시된 정보를 변환기에 보낸다. 서버는 자신의 구역 자원 레코드에 www.net.compsci.googleplex.edu를 변환할 수 있는 정보가 있는지도 검사한다. 예제에서는 캐시 정보도 없고, 도메인도 다르기 때문에 필요한 정보가 없다고 가정한다.
    5. ns1.xyzindustries.com이 네임에 대한 반복적 요청을 생성하고 이를 루트 네임 서버에게 보낸다.
    6. 루트 네임 서버는 이 네임을 변환하지 않고 .edu 도메인을 담당하는 서버의 네임과 주소를 반환한다.
    7. ns1.xyzindustries.com은 반복적 요청을 생성하고 이를 .edu 도메인을 담당하는 서버에게 전송한다.
    8. .edu 도메인을 담당하는 서버는 googleplex.edu를 담당하는 서버의 네임과 주소를 반환한다.
    9. ns1.xyzindustries.com은 반복적 요청을 생성하고 이를 googleplex.edu를 담당하는 서버에게 보낸다.
    10. googleplex.edu 도메인을 담당하는 서버는 자신의 레코드를 찾아본다. 그러나 해당 네임이 개별적인 구역에 있는 compsci.googleplex.edu 하위 도메인에 존재하는 것을 알아내고 그 구역을 담당하는 네임 서버의 주소를 반환한다.
    11. ns1.xyzindustries.com은 반복적 요청을 생성하고 이를 compsci.googleplex.edu를 담당하는 네임 서버로 보낸다.
    12. compsci.googleplex.edu를 담당하는 서버는 www.net.compsci.googleplex.edu의 권한 서버이다. 이 서버는 해당 호스트의 IP 주소를 ns1.xyzindustries.com에 반환한다.
    13. ns1.xyzindustries.com은 변환 정보를 캐시에 저장한다.
    14. 로컬 네임 서버는 변환 정보를 로컬 머신상의 변환기에게 반환한다.
    15. 로컬 변환기가 변환 정보를 캐시에 저장한다.
    16. 로컬 변환기가 브라우저에게 주소를 넘긴다.
    17. 브라우저가 Googleplex 머신의 IP 주소로 HTTP 요청을 시작한다.

## DHCP 프로토콜



## 네트워크 장비

