# Operating System

* [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
* [데드락의 발생 조건](#데드락의-발생-조건)
* [가상메모리](#가상메모리)
* [선점형 스케줄링과 비선점형 스케줄링](#선점형-스케줄링과-비선점형-스케줄링)
* [PCB와 프로세스 컨텍스트](#PCB와-프로세스-컨텍스트)

---

## 프로세스와 쓰레드의 차이

* 공룡책 등에 소개되는 개념에 의하면 프로세스는 실행 혹은 실행 가능 상태에 있는 프로그램 인스턴스이고, 쓰레드는 프로세스 안에서 실행되는 흐름의 단위로 CPU 이용의 기본 단위이다.
* 프로세스의 메모리는 역할에 따라 크게 Code, Data, Heap, Stack 세그먼트로 구분된다.
    * Code 세그먼트는 프로그램 명령어를 구성하는 메모리 영역이다.
    * Data 세그먼트는 전역/정적 변수를 저장하는 영역이다.
        * 읽기 전용 데이터는 .rodata, 초기화 된 데이터는 .data, 초기화 되지 않은 데이터는 .bss 영역에 저장한다.
    * Heap 세그먼트는 동적 할당 시 사용한다.
    * Stack 세그먼트는 함수의 스택 프레임(지역 변수, 매개 변수, 리턴 값 등)을 구성할 때 사용한다.
* 이론적으로 프로세스는 각각 독립된 메모리 영역을 할당받아서, 한 프로세스는 다른 프로세스의 메모리에 접근할 수 없다. (가상메모리 개념과 연계됨)
* 이론적으로 쓰레드는 프로세스 내에서 레지스터와 Stack 세그먼트만 따로 할당받고, 그 외의 세그먼트는 공유한다.
* 실제 구현상(UNIX, Linux, MAC OS, Windows 등) 위의 내용은 일부 일치하지 않을 수 있다.
    * 예를 들어 Linux에서는 프로세스와 쓰레드를 모두 ```struct task_struct```로 표현한다. 리눅스 커널에서 새로운 프로세스나 쓰레드 생성의 실질적인 처리는 ```kernel_clone()```에서 이루어진다. (과거 ```_do_fork()``` 함수였다가 이름 변경됨) 해당 함수 내부에서는 ```copy_process()``` 함수를 호출하여 부모 프로세스의 여러 내용을 복사해주는데, 유저 스페이스로부터 전달받은 CLONE_FLAG에 따라 복사하는 내용이 달라진다. 그리고 유저 스페이스에서 호출하는 시스템콜에 따라 (프로세스 생성 시스템콜인지 쓰레드 생성 시스템콜인지 따라) 이 CLONE_FLAG가 달라지게 되어, 부모 프로세스로부터 복사받는 내용과 별개로 할당되는 내용 등의 범위가 달라지게 되는 것이다.
* 공룡책에서 소개되는 개념에 의하면 이론적으로 쓰레드가 CPU 이용의 기본 단위라고 하였는데, 실제로는 jail(FreeBSD)이나 cgroup(Linux) 등의 개념 도입에 따라 별도 스케줄링 유닛으로 대체되었다. 리눅스의 경우 ```struct sched_entity```가 스케줄링을 위한 기본 유닛이 되며, ```struct task_struct```는 멤버로 ```struct sched_entity``` 객체를 포함하게 된다.

## 데드락의 발생 조건

* Mutual Exclusion (상호 배제) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
* Hold and Wait (점유 대기) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
* No Preemption (비선점) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
* Circular Wait (순환 대기) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
* 데드락은 위 네 가지 조건을 만족하면 발생한다.
* 여기서 No Preemption은 Non-preemptive 스케줄링 방식을 뜻하는 것이 아니라, 락 메커니즘 자체가 선점 불가능한 경우를 뜻한다.

## 가상메모리

* 가상 메모리는 프로세스가 동작할 때 가상의 메모리 레이아웃 위에서 동작할 수 있게 하는 메모리 관리 기법이다.
* 이로 인하여 볼 수 있는 대표적인 효과들은 다음과 같다.
    * 프로세스에서 실제 하드웨어 메모리 레이아웃을 몰라도 프로그래밍을 할 수 있다.
    * 실제 주기억장치 크기보다 큰 메모리를 할당받을 수 있다.
    * 프로세스마다 서로 독립적인 공간을 할당받게 되어 서로 간섭하지 않게 할 수 있다.

## 선점형 스케줄링과 비선점형 스케줄링

* 선점형(Preemptive) 스케줄링 : 어떤 쓰레드가 CPU를 할당받아 실행 중에 있어도 다른 쓰레드가 실행 중인 쓰레드를 중지하고 CPU를 강제로 점유할 수 있는 스케줄링 방식이다. 빠른 응답시간을 요구하는 시분할 시스템에 적합하다.
    * 대표 알고리즘 : 라운드 로빈 스케줄링, 멀티레벨 큐 스케줄링
* 비선점(Non-preemptive) 스케줄링 : 어떤 쓰레드가 CPU를 할당 받으면 그 쓰레드가 종료되거나 IO가 발생하여 자발적으로 중지될 때까지 계속 실행하도록 보장하는 스케줄링 방식이다. 작업의 응답 시간을 예상할 수 있지만 처리율이 떨어질 수 있다. 주로 일괄 처리 시스템에 적합하다.
    * 대표 알고리즘 : FCFS(First Come First Served), SJF(Shortest Job First)
* 실제로 사용되는 스케줄링 알고리즘은 ULE(FreeBSD)와 CFS(Linux)가 있다.
    * CFS는 태스크들의 우선순위를 기반으로 상대적 실행시간인 vruntime을 계산하여, 시스템에 존재하는 모든 태스크의 vruntime이 비슷하게 맞춰지도록 스케줄링하는 선점형 스케줄러이다.
    * 실제로 시스템에는 하나의 스케줄러만 사용하는 것이 아니라, 태스크(프로세스/쓰레드)에 리얼타임 우선순위, 일반 우선순위 등을 구분하여 부여한 후 우선순위에 따라 서로 다른 스케줄러에서 처리할 수 있도록 구성되어 있다. 예를 들어 -100부터 -1까지는 RT 우선순위이고 0부터 39까지는 일반 우선순위여서 해당 우선순위에 따라 데드라인 스케줄러가 처리하거나 CFS 스케줄러가 처리하는 등의 방식이다.

## PCB와 프로세스 컨텍스트

* PCB(Process Control Block)은 프로세스 관리를 위한 메타데이터를 저장하고 있는 커널에서 관리하는 자료구조이다.
    * 이론적으로 다음과 같은 정보들을 포함한다.
        * PID
        * Process State : create, ready, running, waiting, terminated
        * Program Counter : 이 프로세스가 다음에 실행할 명령어의 주소
        * Process Context
        * 스케줄링 정보
        * 메모리 관리 정보
        * 기타 프로세스 정보
* 프로세스 컨텍스트 : CPU가 해당 프로세스를 실행하기 위한 프로세스의 데이터 모음이다.
    * 인터럽트가 발생했을 때, 인터럽트 핸들러를 수행한 후 원래 코드로 복귀하려면 프로세서의 상태를 저장하고 복원해야 한다. 프로세서는 레지스터를 기반으로 코드를 수행하므로 프로세서의 상태는 코드 수행에 관계된 레지스터의 집합이라고 할 수 있다. 이렇게 프로세서의 상태와 관계된 레지스터의 집합을 컨텍스트라고 한다.
    * 일반적으로 저장 및 복원하는 레지스터는 다음과 같다. (SS ~ IP는 프로세서가 처리하며, 커널의 핸들러는 그 외 부분을 처리한다.)
        * SS : 스택 영역을 가리키는 세그먼트 레지스터
        * SP : 현재 스택의 주소를 저장하는 포인터 레지스터
        * FLAGS : 상태 플래그를 저장하는 레지스터
        * CS : 코드 영역을 가리키는 세그먼트 레지스터
        * IP : 프로세서가 읽고 있는 현재 명령어의 위치를 가리키는 포인터 레지스터
        * BP : 스택의 데이터에 접근할 때 사용하는 포인터 레지스터
        * 범용 레지스터(AX ~ R15)
        * 세그먼트 셀렉터(DS ~ GS)
* 컨텍스트 스위칭 : 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전 프로세스의 컨텍스트를 보관하고 새로운 프로세스의 컨텍스트를 적재하는 작업
    * 컨텍스트 스위칭을 자주할수록 컨텍스트 저장 및 적재 등에 의한 오버헤드가 생겨서 시스템 전체적인 성능이 저하한다. 반대로 컨텍스트 스위칭을 너무 적게 하면 원하는 작업에 대한 반응 속도가 늦어진다. 따라서 적절한 빈도의 컨텍스트 스위칭을 수행해야 한다.
* 실제 리눅스 커널에서 프로세스 및 쓰레드를 관리하기 위하여 사용하는 구조체는 ```struct task_struct```이며, 해당 구조체가 PCB의 역할을 수행한다.
    * ```struct task_struct```의 주요 멤버는 다음과 같다.
        * ```struct thread_info thread_info``` : 아키텍처별로(x86/arm 등) 구현되어 있으며 주로 프로세스 컨텍스트 관련 정보들을 저장한다.
        * ```struct mm_struct *mm``` : 프로세스가 관리하는 메모리 관련 정보를 가리킨다.
        * ```pid_t pid``` : 프로세스의 pid
        * ```int prio``` : 프로세스의 우선순위
        * 해당 구조체는 매우 거대한 구조체이므로 그 외에도 정말 많은 멤버들을 포함한다. 자세한 정의를 보고 싶으면 [링크](https://elixir.bootlin.com/linux/v5.14.11/source/include/linux/sched.h#L661)를 참고한다.