# Operating System

* [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
* [데드락의 발생 조건](#데드락의-발생-조건)
* [가상메모리](#가상메모리)
* [페이징과 세그먼테이션](#페이징과-세그먼테이션)
* [페이지 교체 알고리즘](#페이지-교체-알고리즘)
* [선점형 스케줄링과 비선점형 스케줄링](#선점형-스케줄링과-비선점형-스케줄링)
* [PCB와 프로세스 컨텍스트](#PCB와-프로세스-컨텍스트)

---

## 프로세스와 쓰레드의 차이

* 공룡책 등에 소개되는 개념에 의하면 프로세스는 실행 혹은 실행 가능 상태에 있는 프로그램 인스턴스이고, 쓰레드는 프로세스 안에서 실행되는 흐름의 단위로 CPU 이용의 기본 단위이다.
* 프로세스의 메모리는 역할에 따라 크게 Code, Data, Heap, Stack 세그먼트로 구분된다.
    * Code 세그먼트는 프로그램 명령어를 구성하는 메모리 영역이다.
    * Data 세그먼트는 전역/정적 변수를 저장하는 영역이다.
        * 읽기 전용 데이터는 .rodata, 초기화 된 데이터는 .data, 초기화 되지 않은 데이터는 .bss 영역에 저장한다.
    * Heap 세그먼트는 동적 할당 시 사용한다.
    * Stack 세그먼트는 함수의 스택 프레임(지역 변수, 매개 변수, 리턴 값 등)을 구성할 때 사용한다.
* 이론적으로 프로세스는 각각 독립된 메모리 영역을 할당받아서, 한 프로세스는 다른 프로세스의 메모리에 접근할 수 없다. (가상메모리 개념과 연계됨)
* 이론적으로 쓰레드는 프로세스 내에서 레지스터와 Stack 세그먼트만 따로 할당받고, 그 외의 세그먼트는 공유한다.
* 실제 구현상(UNIX, Linux, MAC OS, Windows 등) 위의 내용은 일부 일치하지 않을 수 있다.
    * 예를 들어 Linux에서는 프로세스와 쓰레드를 모두 ```struct task_struct```로 표현한다. 리눅스 커널에서 새로운 프로세스나 쓰레드 생성의 실질적인 처리는 ```kernel_clone()```에서 이루어진다. (과거 ```_do_fork()``` 함수였다가 이름 변경됨) 해당 함수 내부에서는 ```copy_process()``` 함수를 호출하여 부모 프로세스의 여러 내용을 복사해주는데, 유저 스페이스로부터 전달받은 CLONE_FLAG에 따라 복사하는 내용이 달라진다. 그리고 유저 스페이스에서 호출하는 시스템콜에 따라 (프로세스 생성 시스템콜인지 쓰레드 생성 시스템콜인지 따라) 이 CLONE_FLAG가 달라지게 되어, 부모 프로세스로부터 복사받는 내용과 별개로 할당되는 내용 등의 범위가 달라지게 되는 것이다.
* 공룡책에서 소개되는 개념에 의하면 이론적으로 쓰레드가 CPU 이용의 기본 단위라고 하였는데, 실제로는 jail(FreeBSD)이나 cgroup(Linux) 등의 개념 도입에 따라 별도 스케줄링 유닛으로 대체되었다. 리눅스의 경우 ```struct sched_entity```가 스케줄링을 위한 기본 유닛이 되며, ```struct task_struct```는 멤버로 ```struct sched_entity``` 객체를 포함하게 된다.

## 데드락의 발생 조건

* Mutual Exclusion (상호 배제) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
* Hold and Wait (점유 대기) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
* No Preemption (비선점) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
* Circular Wait (순환 대기) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
* 데드락은 위 네 가지 조건을 만족하면 발생한다.
* 여기서 No Preemption은 Non-preemptive 스케줄링 방식을 뜻하는 것이 아니라, 락 메커니즘 자체가 선점 불가능한 경우를 뜻한다.

## 가상메모리

* 가상 메모리는 프로세스가 동작할 때 가상의 메모리 레이아웃 위에서 동작할 수 있게 하는 메모리 관리 기법이다.
* 이로 인하여 볼 수 있는 대표적인 효과들은 다음과 같다.
    * 프로세스에서 실제 하드웨어 메모리 레이아웃을 몰라도 프로그래밍을 할 수 있다.
    * 실제 주기억장치 크기보다 큰 메모리를 할당받을 수 있다.
    * 프로세스마다 서로 독립적인 공간을 할당받게 되어 서로 간섭하지 않게 할 수 있다.

## 페이징과 세그먼테이션

* 페이징과 세그먼테이션은 메모리를 분할하여 사용하는 메모리 관리 기법이다.
* 페이징 : 메모리를 일정한 크기의 페이지와 페이지 프레임으로 나눠서 관리한다. (고정 분할 기법)
    * 프레임 : 물리 메모리를 일정한 크기로 나눈 블록
    * 페이지 : 가상 메모리를 일정한 크기로 나눈 블록
    * 페이지와 프레임의 크기는 같으며, 일반적인 데스크탑에서 보통 4K의 크기를 갖는다.
    * 페이지가 프레임을 할당 받으면 메인 메모리에 위치하게 되며, 프레임을 할당 받지 못한 페이지들은 보조 기억장치에 저장된다.
* 세그먼테이션 : 프로세스의 메모리를 논리적인 내용을 기반으로 나눠서 배치 및 관리한다. (동적 분할 기법)
    * 세그먼테이션을 구현하기 위하여 세그먼트 셀렉터, 세그먼트 디스크립터, 세그먼트 테이블이 사용된다.
    * 세그먼트 셀렉터 : 세그먼트 디스크립터를 가리키는 레지스터
    * 세그먼트 디스크립터 : 세그먼트에 대한 정보를 가지고 있는 자료구조
    * 세그먼트 테이블 : 세그먼트 디스크립터를 모아둔 테이블
    * 선형 주소 접근 과정
        1. GDTR/LDTR 레지스터로 세그먼트 디스크립터의 주소를 구한다.
        2. 디스크립터 주소에 세그먼트 셀렉터의 주소 값을 더해(인덱스에 8을 곱하여 더함) 세그먼트 디스크립터의 주소를 구한다.
        3. 세그먼트 디스크립터에 있는 Base Address로 세그먼트의 시작 주소를 얻는다.
        4. 세그먼트 시작 주소에 선형 주소의 Offset을 더해 원하는 데이터 주소를 구한다.
* 페이징 기법을 사용하면 필요한 메모리보다 더 큰 양의 메모리를 할당해서 메모리 블록의 내부가 낭비되는 내부 단편화가 생긴다.
    * 예를 들어 1KB의 메모리를 필요로 하는 프로세스에게 4KB의 페이지를 할당하면 내부적으로 3KB는 낭비된다.
* 세그먼테이션 기법을 사용하면 메모리가 할당되고 해제되는 작업이 반복될 때 중간에 생긴 사용하지 않는 메모리가 쌓여 가용 메모리는 충분하지만 원하는 크기의 연속된 메모리를 할당할 수 없는 외부 단편화가 생긴다.
    * 예를 들어 6KB 메모리에 0~1KB, 2~3KB, 4~5KB 영역이 할당되어 있는데, 연속된 2KB 메모리를 추가로 할당해야 한다면 가용 메모리(3KB)는 충분하지만 연속된 영역을 할당할 수 없다.
* 위와 같은 문제를 해결하기 위하여 세그먼트를 페이징 기법으로 나누는 Paged segmentation 기법을 사용한다.
* 물론, 이번 내용도 실제 구현과 일부 상이할 수 있다.
    * 프로세서에는 운영모드라는게 존재한다. 16비트 리얼 모드에서는 세그먼테이션 기법만 사용하고, 세그먼테이션을 거쳐 나온 주소가 바로 물리 주소가 된다. 32비트 보호 모드에서는 세그먼테이션을 거쳐 나온 선형 주소가 페이징을 사용한다면 페이징의 입력 값이 된다. 64비트 LONG 모드 혹은 IA-32e 모드에서는 세그먼테이션을 통한 메모리 지정이 의미를 잃는다. (세그먼트 디스크립터에 있는 값이 무시된다.) 따라서 64비트 시스템에서는 세그먼테이션을 사용하지 않거나 아주 한정적으로(메모리 보호 기능을 위해) 사용된다.
    * 실제 리눅스의 경우 ```struct page``` 구조체를 이용하여 페이지를 나타내며, 이론상 5단계의 주소 변환을 통해 페이징 기법을 적용하고 있다. (실제로는 3/4단계로 축소될 수 있다.) 메모리 관리를 위해 따로 세그먼테이션을 수행하지는 않으며, 프로그램의 메모리를 논리적인 세그먼트로 나누기만 한다. 세그먼트 셀렉터 레지스터는 다른 용도로 사용된다.

## 페이지 교체 알고리즘



## 선점형 스케줄링과 비선점형 스케줄링

* 선점형(Preemptive) 스케줄링 : 어떤 쓰레드가 CPU를 할당받아 실행 중에 있어도 다른 쓰레드가 실행 중인 쓰레드를 중지하고 CPU를 강제로 점유할 수 있는 스케줄링 방식이다. 빠른 응답시간을 요구하는 시분할 시스템에 적합하다.
    * 대표 알고리즘 : 라운드 로빈 스케줄링, 멀티레벨 큐 스케줄링
* 비선점(Non-preemptive) 스케줄링 : 어떤 쓰레드가 CPU를 할당 받으면 그 쓰레드가 종료되거나 IO가 발생하여 자발적으로 중지될 때까지 계속 실행하도록 보장하는 스케줄링 방식이다. 작업의 응답 시간을 예상할 수 있지만 처리율이 떨어질 수 있다. 주로 일괄 처리 시스템에 적합하다.
    * 대표 알고리즘 : FCFS(First Come First Served), SJF(Shortest Job First)
* 실제로 사용되는 스케줄링 알고리즘은 ULE(FreeBSD)와 CFS(Linux)가 있다.
    * CFS는 태스크들의 우선순위를 기반으로 상대적 실행시간인 vruntime을 계산하여, 시스템에 존재하는 모든 태스크의 vruntime이 비슷하게 맞춰지도록 스케줄링하는 선점형 스케줄러이다.
    * 실제로 시스템에는 하나의 스케줄러만 사용하는 것이 아니라, 태스크(프로세스/쓰레드)에 리얼타임 우선순위, 일반 우선순위 등을 구분하여 부여한 후 우선순위에 따라 서로 다른 스케줄러에서 처리할 수 있도록 구성되어 있다. 예를 들어 -100부터 -1까지는 RT 우선순위이고 0부터 39까지는 일반 우선순위여서 해당 우선순위에 따라 데드라인 스케줄러가 처리하거나 CFS 스케줄러가 처리하는 등의 방식이다.

## PCB와 프로세스 컨텍스트

* PCB(Process Control Block)은 프로세스 관리를 위한 메타데이터를 저장하고 있는 커널에서 관리하는 자료구조이다.
    * 이론적으로 다음과 같은 정보들을 포함한다.
        * PID
        * Process State : create, ready, running, waiting, terminated
        * Program Counter : 이 프로세스가 다음에 실행할 명령어의 주소
        * Process Context
        * 스케줄링 정보
        * 메모리 관리 정보
        * 기타 프로세스 정보
* 프로세스 컨텍스트 : CPU가 해당 프로세스를 실행하기 위한 프로세스의 데이터 모음이다.
    * 인터럽트가 발생했을 때, 인터럽트 핸들러를 수행한 후 원래 코드로 복귀하려면 프로세서의 상태를 저장하고 복원해야 한다. 프로세서는 레지스터를 기반으로 코드를 수행하므로 프로세서의 상태는 코드 수행에 관계된 레지스터의 집합이라고 할 수 있다. 이렇게 프로세서의 상태와 관계된 레지스터의 집합을 컨텍스트라고 한다.
    * 일반적으로 저장 및 복원하는 레지스터는 다음과 같다. (SS ~ IP는 프로세서가 처리하며, 커널의 핸들러는 그 외 부분을 처리한다.)
        * SS : 스택 영역을 가리키는 세그먼트 레지스터
        * SP : 현재 스택의 주소를 저장하는 포인터 레지스터
        * FLAGS : 상태 플래그를 저장하는 레지스터
        * CS : 코드 영역을 가리키는 세그먼트 레지스터
        * IP : 프로세서가 읽고 있는 현재 명령어의 위치를 가리키는 포인터 레지스터
        * BP : 스택의 데이터에 접근할 때 사용하는 포인터 레지스터
        * 범용 레지스터(AX ~ R15)
        * 세그먼트 셀렉터(DS ~ GS)
        * OS마다 처리하는 레지스터 종류들은 달라질 수 있으며, 어떤 레지스터를 처리하는지까지 숙지할 필요는 없다. (주로 스택이나 명령어에 대한 정보들을 담고있는 레지스터들과 범용 레지스터들을 저장한다고 알고있으면 된다.)
* 컨텍스트 스위칭 : 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전 프로세스의 컨텍스트를 보관하고 새로운 프로세스의 컨텍스트를 적재하는 작업
    * 컨텍스트 스위칭을 자주할수록 컨텍스트 저장 및 적재 등에 의한 오버헤드가 생겨서 시스템 전체적인 성능이 저하한다. 반대로 컨텍스트 스위칭을 너무 적게 하면 원하는 작업에 대한 반응 속도가 늦어진다. 따라서 적절한 빈도의 컨텍스트 스위칭을 수행해야 한다.
* 실제 리눅스 커널에서 프로세스 및 쓰레드를 관리하기 위하여 사용하는 구조체는 ```struct task_struct```이며, 해당 구조체가 PCB의 역할을 수행한다.
    * ```struct task_struct```의 주요 멤버는 다음과 같다.
        * ```struct thread_info thread_info``` : 아키텍처별로(x86/arm 등) 구현되어 있으며 주로 프로세스 컨텍스트 관련 정보들을 저장한다.
        * ```struct mm_struct *mm``` : 프로세스가 관리하는 메모리 관련 정보를 가리킨다.
        * ```pid_t pid``` : 프로세스의 pid
        * ```int prio``` : 프로세스의 우선순위
        * 해당 구조체는 매우 거대한 구조체이므로 그 외에도 정말 많은 멤버들을 포함한다. 자세한 정의를 보고 싶으면 [링크](https://elixir.bootlin.com/linux/v5.14.11/source/include/linux/sched.h#L661)를 참고한다.