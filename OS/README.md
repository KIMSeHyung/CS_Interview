# Operating System

* [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
* [데드락의 발생 조건](#데드락의-발생-조건)
* [가상메모리](#가상메모리)
* [선점형 스케줄링과 비선점형 스케줄링](#선점형-스케줄링과-비선점형-스케줄링)
* [컨텍스트 스위칭](#컨텍스트-스위칭)

---

## 프로세스와 쓰레드의 차이

* 공룡책 등에 소개되는 개념에 의하면 프로세스는 실행 혹은 실행 가능 상태에 있는 프로그램 인스턴스이고, 쓰레드는 프로세스 안에서 실행되는 흐름의 단위로 CPU 이용의 기본 단위이다.
* 프로세스의 메모리는 역할에 따라 크게 Code, Data, Heap, Stack 세그먼트로 구분된다.
    * Code 세그먼트는 프로그램 명령어를 구성하는 메모리 영역이다.
    * Data 세그먼트는 전역/정적 변수를 저장하는 영역이다.
        * 읽기 전용 데이터는 .rodata, 초기화 된 데이터는 .data, 초기화 되지 않은 데이터는 .bss 영역에 저장한다.
    * Heap 세그먼트는 동적 할당 시 사용한다.
    * Stack 세그먼트는 함수의 스택 프레임(지역 변수, 매개 변수, 리턴 값 등)을 구성할 때 사용한다.
* 이론적으로 프로세스는 각각 독립된 메모리 영역을 할당받아서, 한 프로세스는 다른 프로세스의 메모리에 접근할 수 없다. (가상메모리 개념과 연계됨)
* 이론적으로 쓰레드는 프로세스 내에서 레지스터와 Stack 세그먼트만 따로 할당받고, 그 외의 세그먼트는 공유한다.
* 실제 구현상(UNIX, Linux, MAC OS, Windows 등) 위의 내용은 일부 일치하지 않을 수 있다.
    * 예를 들어 Linux에서는 프로세스와 쓰레드를 모두 ```struct task_struct```로 표현한다. 리눅스 커널에서 새로운 프로세스나 쓰레드 생성의 실질적인 처리는 ```kernel_clone()```에서 이루어진다. (과거 ```_do_fork()``` 함수였다가 이름 변경됨) 해당 함수 내부에서는 ```copy_process()``` 함수를 호출하여 부모 프로세스의 여러 내용을 복사해주는데, 유저 스페이스로부터 전달받은 CLONE_FLAG에 따라 복사하는 내용이 달라진다. 그리고 유저 스페이스에서 호출하는 시스템콜에 따라 (프로세스 생성 시스템콜인지 쓰레드 생성 시스템콜인지 따라) 이 CLONE_FLAG가 달라지게 되어, 부모 프로세스로부터 복사받는 내용과 별개로 할당되는 내용 등의 범위가 달라지게 되는 것이다.
* 공룡책에서 소개되는 개념에 의하면 이론적으로 쓰레드가 CPU 이용의 기본 단위라고 하였는데, 실제로는 jail(FreeBSD)이나 cgroup(Linux) 등의 개념 도입에 따라 별도 스케줄링 유닛으로 대체되었다. 리눅스의 경우 ```struct sched_entity```가 스케줄링을 위한 기본 유닛이 되며, ```struct task_struct```는 멤버로 ```struct sched_entity``` 객체를 포함하게 된다.

## 데드락의 발생 조건

* Mutual Exclusion (상호 배제) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
* Hold and Wait (점유 대기) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
* No Preemption (비선점) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
* Circular Wait (순환 대기) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
* 데드락은 위 네 가지 조건을 만족하면 발생한다.
* 여기서 No Preemption은 Non-preemptive 스케줄링 방식을 뜻하는 것이 아니라, 락 메커니즘 자체가 선점 불가능한 경우를 뜻한다.

## 가상메모리

* 가상 메모리는 프로세스가 동작할 때 가상의 메모리 레이아웃 위에서 동작할 수 있게 하는 메모리 관리 기법이다.
* 이로 인하여 볼 수 있는 대표적인 효과들은 다음과 같다.
    * 프로세스에서 실제 하드웨어 메모리 레이아웃을 몰라도 프로그래밍을 할 수 있다.
    * 실제 주기억장치 크기보다 큰 메모리를 할당받을 수 있다.
    * 프로세스마다 서로 독립적인 공간을 할당받게 되어 서로 간섭하지 않게 할 수 있다.

## 선점형 스케줄링과 비선점형 스케줄링

## 컨텍스트 스위칭